/*
 * GradleUtils
 * Copyright (C) 2021 Forge Development LLC
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

package net.neoforged.gradleutils.tasks;

import org.eclipse.jgit.api.Git;
import org.gradle.api.UnknownDomainObjectException;
import org.gradle.api.publish.PublishingExtension;
import org.gradle.api.publish.maven.MavenPublication;
import org.gradle.api.tasks.TaskAction;
import org.gradle.util.GradleVersion;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.Objects;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Task to extract the TeamCity project configuration from the included template zpi file and the github remote information.
 */
public abstract class ExtractTeamCityProjectConfigurationTask extends CIConfigExtractionTask {

    public ExtractTeamCityProjectConfigurationTask() {
        super(".teamcity.zip", ".teamcity");
        setDescription("Creates (or recreates) a default TeamCity project configuration directory for use with the MinecraftForge TeamCity server.");
    }

    @TaskAction
    public void run() throws Exception {
        super.run();
        //Replace the default project ids with ours.
        replaceTeamCityTestProjectIds(getDestination().getAsFile().get());
    }

    /**
     * Extracts the .teamcity.zip file to our target directory.
     *
     * @param fileZip The teamcity zip file.
     * @param destDir The target directory (generally the project directory), where the .teamcity.zip file will be extracted.
     */
    @Override
    protected void extractZip(final String fileZip, final File destDir) throws Exception {
        byte[] buffer = new byte[1024];
        ZipInputStream zis = new ZipInputStream(new FileInputStream(fileZip));
        ZipEntry zipEntry = zis.getNextEntry();
        while (zipEntry != null) {
            File newFile = newFile(destDir, zipEntry);
            if (zipEntry.isDirectory()) {
                if (!newFile.isDirectory() && !newFile.mkdirs()) {
                    throw new IOException("Failed to create directory " + newFile);
                }
            } else {
                // fix for Windows-created archives
                File parent = newFile.getParentFile();
                if (!parent.isDirectory() && !parent.mkdirs()) {
                    throw new IOException("Failed to create directory " + parent);
                }

                // write file content
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
            }
            zipEntry = zis.getNextEntry();
        }
        zis.closeEntry();
        zis.close();
    }

    /**
     * Parses the existing .teamcity directory files for "TeamCityTest" and replaces it with a new project id,
     * generated by checking the first remote on the current git project.
     *
     * @param projectDir The project directory to run the replacement in.
     */
    @SuppressWarnings("ReadWriteStringCanBeUsed") //We still need to support older versions of the JDK.
    private void replaceTeamCityTestProjectIds(final File projectDir) throws Exception {
        try (final Git git = Git.open(projectDir)) {
            final String projectId = determineGitHubProjectName(git);
            final File teamcityDir = new File(projectDir, ".teamcity");
            if (!teamcityDir.exists()) {
                return;
            }

            for (final File file : Objects.requireNonNull(teamcityDir.listFiles((dir, name) -> name.endsWith("kts")))) {
                String content = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
                content = content.replaceAll("%projectName%", projectId);
                content = content.replaceAll("%projectOrg%", determineGitHubProjectOrganisation(git));
                content = content.replaceAll("%projectArtifactId%", determineArtifactId(projectId));
                content = content.replaceAll("%projectArtifactGroup%", determineGroup(getProject().getGroup().toString()));
                content = content.replaceAll("%jdkVersion%", determineJDKVersion());
                content = content.replaceAll("%gradleVersion%", GradleVersion.current().getVersion());
                Files.write(file.toPath(), content.getBytes(StandardCharsets.UTF_8));
            }

            String projectGroup = determineGitHubProjectOrganisation(git);
            if (!projectGroup.equals("MinecraftForge")) {
                projectGroup = "MinecraftForge_" + projectGroup;
            }

            for (final File file : Objects.requireNonNull(teamcityDir.listFiles((dir, name) -> name.endsWith("xml")))) {
                String content = new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);
                content = content.replaceAll("%projectName%", projectId);
                content = content.replaceAll("%projectGroup%", projectGroup);
                Files.write(file.toPath(), content.getBytes(StandardCharsets.UTF_8));
            }
        }
    }

    private String determineArtifactId(String projectId) {
        if (getProject().getExtensions().findByType(PublishingExtension.class) == null) {
            getProject().getLogger().warn("Could not find the Maven publication extension, falling back to the lower cased project name.");
            return projectId.toLowerCase();
        }

        try {
            return getProject().getExtensions().getByType(PublishingExtension.class)
                    .getPublications()
                    .stream()
                    .filter(MavenPublication.class::isInstance)
                    .map(MavenPublication.class::cast)
                    .filter(publication -> !publication.getName().contains("PluginMarker")) //Exclude gradles plugin markers!
                    .findFirst()
                    .map(MavenPublication::getArtifactId)
                    .orElseGet(() -> {
                        getProject().getLogger().warn("Could not find the Maven artifact Id from normal publication falling back to the lower cased project name.");
                        return projectId.toLowerCase();
                    });
        } catch (UnknownDomainObjectException unknownDomainObjectException) {
            getProject().getLogger().warn("Could not find the Maven publication extension, falling back to the lower cased project name.");
            return projectId.toLowerCase();
        }

    }

    private String determineGroup(String fallback) {
        if (getProject().getExtensions().findByType(PublishingExtension.class) == null) {
            getProject().getLogger().warn("Could not find the Maven publication extension, falling back to the lower cased project group.");
            return fallback.toLowerCase();
        }

        try {
            return getProject().getExtensions().getByType(PublishingExtension.class)
                    .getPublications()
                    .stream()
                    .filter(MavenPublication.class::isInstance)
                    .map(MavenPublication.class::cast)
                    .filter(publication -> !publication.getName().contains("PluginMarker")) //Exclude gradles plugin markers!
                    .findFirst()
                    .map(MavenPublication::getGroupId)
                    .orElseGet(() -> {
                        getProject().getLogger().warn("Could not find the Maven artifact Id from normal publication falling back to the lower cased project group.");
                        return fallback.toLowerCase();
                    });
        } catch (UnknownDomainObjectException unknownDomainObjectException) {
            getProject().getLogger().warn("Could not find the Maven publication extension, falling back to the lower cased project group.");
            return fallback.toLowerCase();
        }
    }

    /**
     * Determines the project name of the project of github.
     * Querries the first remote of the current git project and pulls its fetch URL information to extract the name.
     *
     * @param git the project git
     * @return The project name of the project on github.
     */
    private static String determineGitHubProjectName(final Git git) throws Exception {
        final String repositoryPath = git.remoteList().call().get(0).getURIs().get(0).getPath();

        return repositoryPath.substring(repositoryPath.lastIndexOf("/") + 1).replace(".git", "");
    }

    /**
     * Determines the project name of the organisation of github.
     * Querries the first remote of the current git project and pulls its fetch URL information to extract the name.
     *
     * @param git the project git
     * @return The organisation name of the project on github.
     */
    private static String determineGitHubProjectOrganisation(final Git git) throws Exception {
        final String repositoryPath = git.remoteList().call().get(0).getURIs().get(0).getPath();

        final String[] pathMembers = repositoryPath.split("/");
        return pathMembers[pathMembers.length - 2];
    }
}
